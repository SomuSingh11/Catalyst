export const gitwhizMockData = [
  {
    question:
      "Analyze the repository and explain how real-time chat functionality is implemented in this project. ",
    answer: `Okay, I'll analyze the codebase and explain how real-time chat functionality is implemented.

**Overall Architecture**

The project uses a combination of WebSockets (via Socket.IO) and a REST API to achieve real-time chat functionality. The backend API handles message creation and updates, while Socket.IO is used to broadcast these changes to all connected clients in real-time. The frontend uses React hooks (\`useChatSocket\`) to subscribe to these real-time updates and efficiently update the UI.

**Technologies and Libraries**

* **Frontend:**
    * **React:** For building the UI components.
    * **Socket.IO Client:** (implicitly used within \`useChatSocket\` hook) For establishing and managing WebSocket connections with the server.
    * **\`useChatSocket\` (Custom Hook):** Abstracts the Socket.IO client and provides a clean interface for subscribing to real-time chat updates.
    * **\`useChatQuery\` (Custom Hook):** For fetching initial chat messages and handling pagination.
    * **\`useChatScroll\` (Custom Hook):** For implementing infinite scrolling and managing scroll behavior.
    * **\`axios\`:** For making HTTP requests to the backend API (e.g., for creating and updating messages).
* **Backend:**
    * **Next.js API Routes:** For creating the API endpoints that handle message creation and updates.
    * **Socket.IO Server:** (implicitly used in \`/pages/api/socket/messages\`) For broadcasting real-time updates to connected clients.
    * **Prisma:** For interacting with the database (storing messages, user profiles, etc.).

**Message Flow: Sending, Receiving, and Broadcasting**

1.  **Sending a Message (Frontend):**
    * The user enters a message in the \`ChatInput\` component and submits the form.
    * The \`ChatInput\` component uses \`axios\` to send a POST request to the \`/api/socket/messages\` (or \`/api/socket/direct-messages\`) API endpoint with the message content and relevant metadata (e.g., \`channelId\`, \`serverId\`, or \`conversationId\`).

2.  **Receiving and Broadcasting (Backend):**
    * The \`/api/socket/messages\` API route handles the POST request.
    * It authenticates the user and validates the input data.
    * It uses Prisma (\`db.message.create\`) to store the new message in the database.
    * Crucially, it then uses Socket.IO (\`res?.socket?.server?.io?.emit\`) to broadcast the new message to all connected clients. The message is emitted to a specific "room" or channel identified by a unique key (e.g., \`chat:\${channelId}:messages\`).

3.  **Receiving Updates (Frontend):**
    * The \`useChatSocket\` hook on the frontend is responsible for listening for these real-time updates.
    * It establishes a WebSocket connection to the Socket.IO server.
    * It subscribes to the appropriate channel (e.g., \`chat:\${chatId}:messages\`) to receive updates for that specific chat.
    * When a new message is broadcast on the channel, the \`useChatSocket\` hook receives the event.

4.  **Updating the UI (Frontend):**
    * Inside the \`useChatSocket\` hook, when a new message is received, it updates the chat data. This likely involves using a state management solution or a library like \`swr\` to revalidate the chat data.
    * The \`ChatMessages\` component, which displays the list of messages, is connected to this data. When the data changes, React re-renders the component, and the new message appears in the chat.

**Code Details**

* **\`pages/api/socket/messages/index.ts\` (Backend - API Endpoint):**
    * Handles the POST request for creating new messages.
    * Authenticates the user and validates the input.
    * Stores the message in the database using Prisma.
    * Broadcasts the new message to connected clients using Socket.IO:
        \`\`\`typescript
        res?.socket?.server?.io?.emit(channelKey, message);
        \`\`\`
        where \`channelKey\` is something like \`"chat:channelId:messages"\`.

* **\`components/chat/chat-messages.tsx\` (Frontend - Message Display):**
    * Uses the \`useChatQuery\` hook to fetch paginated messages from the API.
    * Uses the \`useChatSocket\` hook to subscribe to real-time updates.
    * Renders the list of messages using the \`ChatItem\` component.

* **\`hooks/use-chat-socket.ts\` (Frontend - Socket Hook):**
    * This is a *critical* piece. It encapsulates the Socket.IO client logic. It likely contains code similar to this (though the exact implementation isn't shown):

        \`\`\`typescript
        // Inside useChatSocket
        useEffect(() => {
          socket.on(addKey, (newMessage) => {
            // Update the chat data (e.g., using swr's mutate function)
          });

          socket.on(updateKey, (updatedMessage) => {
            // Update the chat data (e.g., using swr's mutate function)
          });

          return () => {
            socket.off(addKey);
            socket.off(updateKey);
          };
        }, [socket, addKey, updateKey]);
        \`\`\`

        Where \`addKey\` and \`updateKey\` are strings like \`"chat:channelId:messages"\` and \`"chat:channelId:messages:update"\`.

* **\`components/chat/chat-input.tsx\` (Frontend - Input Component):**
    * Handles user input and submits new messages to the API.
    * Uses \`axios\` to make the POST request.

**Key Points**

* **Real-time Broadcasting:** Socket.IO is used for broadcasting new messages and updates to all connected clients in real-time.
* **Channel-Based Updates:** Messages are broadcast to specific channels (identified by \`channelId\` or \`conversationId\`), ensuring that only relevant clients receive the updates.
* **Efficient UI Updates:** The \`useChatSocket\` hook and libraries like \`swr\` (likely used internally within the hook) enable efficient UI updates by revalidating the chat data only when new messages are received.
* **REST API for Persistence:** The REST API is used to persist messages in the database and handle initial data loading.
* **Custom Hooks:** The use of custom hooks (\`useChatQuery\`, \`useChatSocket\`, \`useChatScroll\`) promotes code reusability and separation of concerns.

In summary, the project leverages the strengths of both WebSockets (for real-time updates) and a REST API (for data persistence and initial loading) to provide a robust and efficient real-time chat experience. The use of custom hooks simplifies the integration of these technologies into the React components.
`,
    filesReferences: [
      {
        summary:
          "## **Overview:** \nThe `chat-messages.tsx` file is a React component responsible for rendering the chat messages within a channel or conversation. It fetches chat messages using a custom hook `useChatQuery`, handles real-time updates via WebSockets using `useChatSocket`, and manages scrolling with `useChatScroll` to implement infinite scrolling. It also handles loading and error states. The component dynamically renders messages with user details and formats them with timestamps.\n\n## **Core Functionality**\nThis file's primary technical purpose is to display a scrollable list of chat messages, fetched and updated in real-time, within a chat interface.\n\n## **Architectural Pattern**\nN/A\n\n## **Key Abstractions & Logic**\n- **`ChatMessages(props: ChatMessagesProps)`**: This React functional component renders the chat messages. It takes props including `name`, `member`, `chatId`, `apiUrl`, `socketUrl`, `socketQuery`, `paramKey`, `paramValue`, and `type` to configure the chat display and data fetching. It utilizes `useChatQuery` to fetch paginated messages, `useChatSocket` to receive real-time updates, and `useChatScroll` for infinite scrolling. It renders a loading state, error state, or the list of `ChatItem` components based on the query status. The messages are displayed in reverse chronological order.\n- **`MessageWithMemberWithProfile`**: This type alias defines the structure of a message object, including the message content, associated member data, and profile information. It ensures type safety when accessing message properties.\n\n## **Error Handling & Side Effects**\n- **Error Handling:** The component displays an error message with a `ServerCrash` icon if the `useChatQuery` hook returns an error status.\n- **Side Effects:** The component uses the `useChatQuery` hook, which makes API calls to fetch chat messages. The `useChatSocket` hook sets up WebSocket listeners to receive real-time updates, and `useChatScroll` attaches a scroll listener to handle infinite scrolling, triggering API calls to fetch more messages.\n\n## **Dependencies & Interactions**\n- **External:**\n    - `react`: Core React library for building UI components.\n    - `date-fns`: Used for formatting dates and times.\n    - `lucide-react`: Provides icons (`Loader2`, `ServerCrash`) for loading and error states.\n    - `@prisma/client`: Used for defining the types `Member`, `Message`, and `Profile`, defining the data structure used in the chat application.\n- **Internal:**\n    - `ChatWelcome`: A component that displays a welcome message in the chat.\n    - `useChatQuery`: A custom hook for fetching chat messages with pagination.\n    - `ChatItem`: A component that renders a single chat message.\n    - `useChatSocket`: A custom hook for handling real-time updates via WebSockets.\n    - `useChatScroll`: A custom hook for implementing infinite scrolling.\n\n## **Technical Keywords**\nReact, chat messages, real-time updates, WebSockets, infinite scrolling, pagination, custom hooks, data fetching, API calls, component, UI, `useChatQuery`, `useChatSocket`, `useChatScroll`\n",
        fileName: "components/chat/chat-messages.tsx",
        similarity: 0.6999187892599551,
        sourceCode:
          '"use client";\n\nimport { Fragment, useRef, ElementRef } from "react";\nimport { format } from "date-fns";\nimport { Loader2, ServerCrash } from "lucide-react";\nimport { Member, Message, Profile } from "@prisma/client";\n\nimport { ChatWelcome } from "./chat-welcome";\nimport { useChatQuery } from "@/hooks/use-chat-query";\nimport { ChatItem } from "./chat-item";\nimport { useChatSocket } from "@/hooks/use-chat-socket";\nimport { useChatScroll } from "@/hooks/use-chat-scroll";\n\nconst DATE_FORMAT = "d MMM yyyy, HH:mm";\n\ntype MessageWithMemberWithProfile = Message & {\n  member: Member & {\n    profile: Profile;\n  };\n};\n\ninterface ChatMessagesProps {\n  name: string;\n  member: Member;\n  chatId: string;\n  apiUrl: string;\n  socketUrl: string;\n  socketQuery: Record<string, string>;\n  paramKey: "channelId" | "conversationId";\n  paramValue: string;\n  type: "channel" | "conversation";\n}\n\nexport const ChatMessages = ({\n  name,\n  member,\n  chatId,\n  apiUrl,\n  socketUrl,\n  socketQuery,\n  paramKey,\n  paramValue,\n  type,\n}: ChatMessagesProps) => {\n  const queryKey = `chat:${chatId}`;\n\n  // These are same as defined in pages/socket/messages\n  const addKey = `chat:${chatId}:messages`;\n  const updateKey = `chat:${chatId}:messages:update`;\n\n  const chatRef = useRef<ElementRef<"div">>(null);\n  const bottomRef = useRef<ElementRef<"div">>(null);\n\n  const { data, fetchNextPage, hasNextPage, isFetchingNextPage, status } =\n    useChatQuery({\n      queryKey,\n      apiUrl, // "/api/messages"\n      paramKey, // "channelId"\n      paramValue, // {channel.id}\n    });\n\n  // Set up WebSocket listeners for real-time chat updates using the `useChatSocket` hook.\n  // This will listen for add and update events to automatically update the chat data in the UI.\n  useChatSocket({ queryKey, addKey, updateKey });\n  useChatScroll({\n    chatRef,\n    bottomRef,\n    loadMore: fetchNextPage,\n    shouldLoadMore: !isFetchingNextPage && !!hasNextPage,\n    count: data?.pages?.[0]?.items?.length ?? 0,\n  });\n\n  if (status === "pending") {\n    return (\n      <div className="flex flex-col flex-1 justify-center items-center">\n        <Loader2 className="h-7 w-7 text-zinc-500 animate-spin my-4" />\n        <p className="text-xs text-zinc-500 dark:texy-zinc-400">\n          Loading messages...\n        </p>\n      </div>\n    );\n  }\n\n  if (status === "error") {\n    return (\n      <div className="flex flex-col flex-1 justify-center items-center">\n        <ServerCrash className="h-7 w-7 text-zinc-500 my-4" />\n        <p className="text-xs text-zinc-500 dark:texy-zinc-400">\n          Something went wrong!\n        </p>\n      </div>\n    );\n  }\n  return (\n    <div ref={chatRef} className="flex-1 flex flex-col py-4 overflow-y-auto">\n      {/* Display a flexible spacer if there are no previous messages to load */}\n      {!hasNextPage && <div className="flex-1" />}{" "}\n      {/* Display a welcome message if there are no previous messages */}\n      {!hasNextPage && <ChatWelcome type={type} name={name} />}{" "}\n      {/* If there are previous pages (messages) to load, display a button or loader */}\n      {hasNextPage && (\n        <div className="flex justify-center">\n          {isFetchingNextPage ? (\n            <Loader2 className="h-6 w-6 text-zinc-500 animate-spin my-4" />\n          ) : (\n            <button\n              onClick={() => fetchNextPage()}\n              className="text-zinc-500 hover:text-zinc-600 dark:text-zinc-400 text-xs my-4 dark:hover:text-zinc-300 transition"\n            >\n              Load previous messages\n            </button>\n          )}\n        </div>\n      )}\n      <div className="flex flex-col-reverse mt-auto">\n        {data?.pages?.map((group, i) => (\n          <Fragment key={i}>\n            {group.items.map((message: MessageWithMemberWithProfile) => (\n              <ChatItem\n                key={message.id}\n                id={message.id}\n                currentMember={member}\n                member={message.member}\n                content={message.content}\n                fileUrl={message.fileUrl}\n                deleted={message.deleted}\n                timestamp={format(new Date(message.createdAt), DATE_FORMAT)}\n                isUpdated={message.updatedAt !== message.createdAt}\n                socketUrl={socketUrl}\n                socketQuery={socketQuery}\n              />\n            ))}\n          </Fragment>\n        ))}\n      </div>\n      <div ref={bottomRef} />\n    </div>\n  );\n};\n',
      },
      {
        summary:
          "## **Overview:** \nThe `ChatItem.tsx` component is a React component responsible for rendering individual chat messages within a chat interface. It handles message display, editing, deletion, and user interaction (clicking on the user avatar). It manages the state of editing, displays different UI elements based on message type (text, image, PDF), and incorporates user roles and permissions. It interacts with a socket server to update messages.\n\n## **Core Functionality**\nThe primary purpose of this file is to render a single chat message with associated metadata (sender, timestamp, content, file URLs) and provide functionality for editing and deleting the message based on user permissions, leveraging React state and hooks for interactivity.\n\n## **Architectural Pattern**\nReact Component\n\n## **Key Abstractions & Logic**\n- **`ChatItem(props)`**: This React functional component accepts props including message `id`, `content`, `member` (containing profile and role info), `timestamp`, `fileUrl`, `deleted` status, the `currentMember`'s information, `isUpdated` flag, `socketUrl`, and `socketQuery`. It renders a chat message UI element, handling display logic based on the message's properties (e.g., displaying images, PDFs, or text content). It also manages the editing state and provides edit/delete functionality if the user has sufficient permissions. The function returns a JSX element representing the formatted chat item.\n- **`roleIconMap`**: This object maps `MemberRole` enum values (GUEST, MODERATOR, ADMIN) to corresponding Lucide React icon components to visually represent the role.\n- **`formSchema`**: A Zod schema defining the validation rules for the message content when editing. It ensures the content is a string with a minimum length of 1.\n- **`onSubmit(values)`**: An asynchronous function that handles form submission when editing a message. It constructs a URL using `qs.stringifyUrl` to send a PATCH request to the socket server to update the message content. It uses `axios` to make the API call, and resets the form and exits editing mode upon successful submission.\n\n## **Error Handling & Side Effects**\n- **Error Handling:** The `onSubmit` function includes a `try...catch` block to handle potential errors during the API call to update the message. Errors are logged to the console.\n- **Side Effects:**\n  - The component makes an API call to the socket server in the `onSubmit` function to update a message.\n  - It uses the `useModal` hook to open a modal when the user attempts to delete a message.\n  - It uses `router.push` to navigate to a user's conversation when their avatar/name is clicked.\n  - It adds and removes an event listener for the \"Escape\" key to cancel edit mode.\n\n## **Dependencies & Interactions**\n- **External:**\n  - `react`: Core React library for creating UI components.\n  - `next/navigation`: Used for routing within the Next.js application.\n  - `@prisma/client`: Prisma client for interacting with the database (Member, MemberRole, Profile types).\n  - `lucide-react`: Library of icons.\n  - `axios`: HTTP client for making API requests.\n  - `query-string`: Utility for manipulating URL query strings.\n  - `react-hook-form`: Library for form management.\n  - `@hookform/resolvers/zod`: Resolver to integrate Zod validation with React Hook Form.\n  - `zod`: Library for data validation.\n  - `next/image`: Component for optimized image loading.\n- **Internal:**\n  - `UserAvatar`: A component for displaying user avatars.\n  - `ActionTooltip`: A component for displaying tooltips on hover.\n  - `Form`, `FormControl`, `FormField`, `FormItem`: UI components from the application's UI library, likely built with Radix UI or similar.\n  - `Input`: A UI component for text input.\n  - `Button`: A UI component for button elements.\n  - `useModal`: A custom hook for managing the state of a modal.\n  - `cn`: Utility function for conditional class names.\n\n## **Technical Keywords**\nReact component, chat message, editing, deletion, socket, API, form validation, Zod, React Hook Form, UI, permissions, user roles, avatar, file display\n",
        fileName: "components/chat/chat-item.tsx",
        similarity: 0.6728739562527675,
        sourceCode:
          '"use client";\n\nimport { Member, MemberRole, Profile } from "@prisma/client";\nimport { Edit, FileIcon, ShieldAlert, ShieldCheck, Trash } from "lucide-react";\n\nimport { UserAvatar } from "@/components/user-avatar";\nimport { ActionTooltip } from "@/components/action-tooltip";\nimport { Form, FormControl, FormField, FormItem } from "@/components/ui/form";\nimport { Input } from "@/components/ui/input";\nimport { Button } from "@/components/ui/button";\nimport { useRouter, useParams } from "next/navigation";\n\nimport * as z from "zod";\nimport axios from "axios";\nimport qs from "query-string";\nimport { useForm } from "react-hook-form";\nimport { zodResolver } from "@hookform/resolvers/zod";\nimport Image from "next/image";\nimport { useEffect, useState } from "react";\nimport { cn } from "@/lib/utils";\nimport { useModal } from "@/hooks/use-modal-store";\n\ninterface ChatItemProps {\n  id: string;\n  content: string;\n  member: Member & {\n    profile: Profile;\n  };\n  timestamp: string;\n  fileUrl: string | null;\n  deleted: boolean;\n  currentMember: Member;\n  isUpdated: boolean;\n  socketUrl: string;\n  socketQuery: Record<string, string>;\n}\n\nconst roleIconMap = {\n  ["GUEST"]: null,\n  ["MODERATOR"]: <ShieldCheck className="h-4 w-4 ml-2 text-indigo-500" />,\n  ["ADMIN"]: <ShieldAlert className="h-4 w-4 ml-2 text-rose-500" />,\n};\n\nconst formSchema = z.object({\n  content: z.string().min(1),\n});\n\nexport const ChatItem = ({\n  id,\n  content,\n  member,\n  timestamp,\n  fileUrl,\n  deleted,\n  currentMember,\n  isUpdated,\n  socketUrl,\n  socketQuery,\n}: ChatItemProps) => {\n  // State for editing and deleting a message\n  const [isEditing, setIsEditing] = useState(false);\n  const { onOpen } = useModal();\n  const params = useParams();\n  const router = useRouter();\n\n  const onMemberClick = () => {\n    if (member.id === currentMember.id) {\n      return;\n    }\n\n    router.push(`/servers/${params?.serverId}/conversations/${member.id}`);\n  };\n\n  // Add an event listener to handle the \'Escape\' key for canceling edit mode\n  useEffect(() => {\n    const handleKeyDown = (event: any) => {\n      if (event.key === "Escape" || event.keyCode === 27) {\n        setIsEditing(false);\n      }\n    };\n\n    window.addEventListener("keydown", handleKeyDown);\n\n    return () => window.removeEventListener("keydown", handleKeyDown);\n  }, []);\n\n  // Initialize form with React Hook Form and Zod for validation\n  const form = useForm<z.infer<typeof formSchema>>({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      content: content,\n    },\n  });\n\n  // Form submission state\n  const isLoading = form.formState.isSubmitting;\n\n  // Handle form submission\n  const onSubmit = async (values: z.infer<typeof formSchema>) => {\n    try {\n      const url = qs.stringifyUrl({\n        url: `${socketUrl}/${id}`, //id === message.id\n        query: socketQuery,\n      });\n\n      await axios.patch(url, values);\n\n      form.reset();\n      setIsEditing(false);\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  // Reset form content whenever the \'content\' prop changes\n  useEffect(() => {\n    form.reset({\n      content: content,\n    });\n  }, [content]);\n\n  // Determine the file type (e.g., \'pdf\', \'jpg\')\n  const fileType = fileUrl?.split(".").pop();\n\n  // Determine user permissions\n  const isAdmin = currentMember.role === MemberRole.ADMIN;\n  const isModerator = currentMember.role === MemberRole.MODERATOR;\n  const isOwner = currentMember.id === member.id;\n  const canDeleteMessage = !deleted && (isAdmin || isModerator || isOwner);\n  const canEditMessage = !deleted && isOwner && !fileUrl;\n  const isPDF = fileType === "pdf" && fileUrl;\n  const isImage = !isPDF && fileUrl;\n\n  return (\n    <div className="relative group flex items-center hover:bg-black/5 p-4 transition w-full">\n      <div className="group flex gap-x-2 items-start w-full">\n        {/* Display user avatar */}\n        <div\n          onClick={onMemberClick}\n          className="cursor-pointer hover:drop-shadow-md transition"\n        >\n          <UserAvatar src={member.profile.imageUrl} />\n        </div>\n\n        {/* Display message content */}\n        <div className="flex flex-col w-full ">\n          <div className="flex items-center gap-x-2">\n            <div className="flex items-center">\n              <p\n                onClick={onMemberClick}\n                className="font-semibold text-sm hover:underline cursor-pointer"\n              >\n                {member.profile.name}\n              </p>\n              <ActionTooltip label={member.role}>\n                {roleIconMap[member.role]}\n              </ActionTooltip>\n            </div>\n            <span className="text-xs text-zinc-500 dark:text-zinc-400">\n              {timestamp}\n            </span>\n          </div>\n\n          {/* Render image if the message contains an image URL */}\n          {isImage && (\n            <a\n              href={fileUrl}\n              target="_blank"\n              rel="noopener noreferrer"\n              className="relative aspect-square rounded-md mt-2 overflow-hidden border flex items-center bg-secondary h-48 w-48"\n            >\n              <Image\n                src={fileUrl}\n                alt={content}\n                fill\n                className="object-cover"\n              />\n            </a>\n          )}\n\n          {/* Render PDF link if the message contains a PDF URL */}\n          {isPDF && (\n            <div className="relative flex items-center p-2 mt-2 rounded-md bg-background/10">\n              <FileIcon className="h-10 w-10 fill-indigo-200 stroke-indigo-400" />\n              <a\n                href={fileUrl}\n                target="_blank"\n                rel="noopener noreferrer"\n                className="ml-2 text-sm text-indigo-500 dark:text-indigo-400 hover:underline"\n              >\n                PDF File\n              </a>\n            </div>\n          )}\n\n          {/* Render text content if there is no file URL and not in editing mode */}\n          {!fileUrl && !isEditing && (\n            <p\n              className={cn(\n                "text-sm text-zinc-600 dark:text-zinc-300",\n                deleted &&\n                  "italic text-zinc-500 dark:text-zinc-400 text-xs mt-1"\n              )}\n            >\n              {content}\n              {isUpdated && !deleted && (\n                <span className="text-[10px] mx-2 text-zinc-500 dark:text-zinc-400">\n                  (edited)\n                </span>\n              )}\n            </p>\n          )}\n\n          {/* Render form for editing the message */}\n          {!fileUrl && isEditing && (\n            <Form {...form}>\n              <form\n                className="flex items-center w-full gap-x-2 pt-2"\n                onSubmit={form.handleSubmit(onSubmit)}\n              >\n                <FormField\n                  control={form.control}\n                  name="content"\n                  render={({ field }) => (\n                    <FormItem className="flex-1">\n                      <FormControl>\n                        <div className="relativer w-full">\n                          <Input\n                            disabled={isLoading}\n                            className="p-2 bg-zinc-200/90 dark:bg-zinc-700/75 border-none \n                            border-0 focus-visible:ring-0 focus-visible:ring-offset-0 text-zinc-600\n                             dark:text-zinc-200"\n                            placeholder="Edited Message"\n                            {...field}\n                          />\n                        </div>\n                      </FormControl>\n                    </FormItem>\n                  )}\n                />\n                <Button disabled={isLoading} size="sm" variant="primary">\n                  Save\n                </Button>\n              </form>\n              <span className="text-[10px] mt-1 text-zinc-400">\n                Press escape to cancel, enter to save\n              </span>\n            </Form>\n          )}\n        </div>\n      </div>\n\n      {/* Render edit and delete buttons if the user has permission */}\n      {canDeleteMessage && (\n        <div\n          className="hidden group-hover:flex items-center gap-x-2 \n        absolute p-1 -top-2 right-5 bg-white dark:bg-zinc-800 border \n        rounded-sm"\n        >\n          {canEditMessage && (\n            <ActionTooltip label={"Edit"}>\n              <Edit\n                onClick={() => setIsEditing(true)}\n                className="cursor-pointer ml-auto w-4 h-4 text-zinc-500\n               hover:text-zinc-600 dark:hover:text-zinc-300 transition"\n              />\n            </ActionTooltip>\n          )}\n          <ActionTooltip label={"Delete"}>\n            <Trash\n              onClick={() =>\n                onOpen("deleteMessage", {\n                  apiUrl: `${socketUrl}/${id}`, // "/api/socket/messages/[messageId]"\n                  query: socketQuery,\n                })\n              }\n              className="cursor-pointer ml-auto w-4 h-4 text-zinc-500\n               hover:text-zinc-600 dark:hover:text-zinc-300 transition"\n            />\n          </ActionTooltip>\n        </div>\n      )}\n    </div>\n  );\n};\n',
      },
      {
        summary:
          "## **Overview:** \nThis file defines an API endpoint (`/api/socket/messages`) responsible for handling POST requests to create new messages within a specified channel of a Discord-like server. It authenticates the user, validates input data, retrieves server and channel information from the database, creates a new message record, and emits the new message to connected clients via Socket.IO for real-time updates. It is part of the backend API and crucial for the real-time messaging feature.\n\n## **Core Functionality** \nThis file's core function is to receive message creation requests, validate them against server and channel membership, persist the message in the database, and broadcast the new message to connected clients in real-time using Socket.IO.\n\n## **Architectural Pattern** \nMiddleware\n\n## **Key Abstractions & Logic**\n- **`handler(req: NextApiRequest, res: NextApiResponseServerIo)`**: This is the main asynchronous function that handles the incoming POST request. It performs the following steps:\n    1.  **Authentication:** Uses `currentProfilePages(req)` to verify the user's identity. Returns a 401 error if unauthorized.\n    2.  **Input Validation:** Extracts `content`, `fileUrl` from the request body and `serverId`, `channelId` from the query parameters. Returns a 400 error if any of these are missing.\n    3.  **Server Retrieval:** Queries the database (`db.server.findFirst`) to find the server matching the `serverId` and ensuring the user is a member. Returns a 404 error if the server is not found or the user is not a member. Includes members data for checking member status.\n    4.  **Channel Retrieval:** Queries the database (`db.channel.findFirst`) to find the channel matching the `channelId` and `serverId`. Returns a 404 error if the channel is not found.\n    5.  **Member Verification:** Checks if the user is a member of the server. Returns a 404 if the member isn't found.\n    6.  **Message Creation:** Creates a new message in the database (`db.message.create`) with the provided `content`, `fileUrl`, `channelId`, and `memberId`. Includes the member's profile data in the response.\n    7.  **Real-time Emission:** Emits the new message to all connected clients via Socket.IO using a channel-specific key (`chat:${channelId}:messages`).\n    8.  **Response:** Returns a 200 status code with the newly created message if successful.\n\n## **Error Handling & Side Effects**\n- **Error Handling:** The code uses try-catch blocks to handle potential errors during database queries and other operations. It returns appropriate HTTP status codes (400, 401, 404, 405, 500) with error messages in the JSON response. The `console.log` statement logs errors on the server-side.\n- **Side Effects:**\n    -   Writes a new message record to the database.\n    -   Emits a Socket.IO event, triggering real-time updates for connected clients.\n\n## **Dependencies & Interactions**\n- **External:**\n    -   `@/types`: Defines the custom type `NextApiResponseServerIo`.\n    -   `next`: Provides `NextApiRequest` for handling requests and `NextApiResponse` for sending responses.\n- **Internal:**\n    -   `@/lib/current-profile-pages`: Used to authenticate the user and retrieve their profile information.\n    -   `@/lib/db`: Used to interact with the database (Prisma client) for querying and creating data (servers, channels, messages).\n\n## **Technical Keywords**\nNext.js API route, Socket.IO, real-time messaging, Prisma, database interaction, authentication, server-side, message creation, channel, server, member, websocket.\n",
        fileName: "pages/api/socket/messages/index.ts",
        similarity: 0.6625226652536838,
        sourceCode:
          'import { currentProfilePages } from "@/lib/current-profile-pages";\nimport { db } from "@/lib/db";\nimport { NextApiResponseServerIo } from "@/types";\nimport { NextApiRequest } from "next";\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponseServerIo\n) {\n  // Only allow POST requests\n  if (req.method !== "POST") {\n    return res.status(405).json({ error: "Method not allowed" });\n  }\n\n  try {\n    const profile = await currentProfilePages(req);\n    const { content, fileUrl } = req.body;\n    const { serverId, channelId } = req.query;\n\n    if (!profile) {\n      return res.status(401).json({ error: "Unauthorized" });\n    }\n\n    if (!serverId) {\n      return res.status(400).json({ error: "Server ID Missing" });\n    }\n\n    if (!channelId) {\n      return res.status(400).json({ error: "Channel ID Missing" });\n    }\n\n    if (!content) {\n      return res.status(400).json({ error: "Content ID Missing" });\n    }\n\n    // Find the server that matches the provided serverId and contains the user as a member\n    const server = await db.server.findFirst({\n      where: {\n        id: serverId as string,\n        members: {\n          some: {\n            profileId: profile.id,\n          },\n        },\n      },\n      include: {\n        members: true,\n      },\n    });\n\n    if (!server) {\n      return res.status(404).json({ message: "Server not found" });\n    }\n\n    // Find the channel that belongs to the specified server\n    const channel = await db.channel.findFirst({\n      where: {\n        id: channelId as string,\n        serverId: serverId as string,\n      },\n    });\n\n    if (!channel) {\n      return res.status(404).json({ message: "Channel not found" });\n    }\n\n    // Check and retrieve if the user is a member of the server\n    const member = server.members.find(\n      (member) => member.profileId === profile.id\n    );\n\n    if (!member) {\n      return res.status(404).json({ message: "Member not found" });\n    }\n\n    // Create a new message in the specified channel\n    const message = await db.message.create({\n      data: {\n        content: content,\n        fileUrl,\n        channelId: channelId as string,\n        memberId: member.id,\n      },\n      include: {\n        member: {\n          include: {\n            profile: true,\n          },\n        },\n      },\n    });\n\n    // Used to uniquely identify the chat channel within a real-time communication context, such as a WebSocket or Socket.IO server.\n    const channelKey = `chat:${channelId}:messages`;\n\n    // Emit the new message to all connected clients in real-time\n    res?.socket?.server?.io?.emit(channelKey, message);\n\n    return res.status(200).json(message);\n  } catch (error) {\n    console.log("MESSAGE_POST", error);\n    return res.status(500).json({ message: "Internal Error" });\n  }\n}\n',
      },
      {
        summary:
          "## **Overview:** \nThe `useChatScroll.ts` file implements a custom React hook designed to manage scrolling behavior within a chat interface. It handles both loading more messages when the user scrolls to the top of the chat and automatically scrolling to the bottom when new messages are added. This hook abstracts away the complexities of scroll event handling and conditional scrolling logic. It enhances the user experience by providing seamless message loading and viewing.\n\n## **Core Functionality**\nThe file provides a React hook that manages chat scrolling behavior, including loading older messages on scroll-to-top and auto-scrolling to the bottom on new messages.\n\n## **Architectural Pattern**\nReact Hook\n\n## **Key Abstractions & Logic**\n- **`useChatScroll({ chatRef, bottomRef, shouldLoadMore, loadMore, count })`**: This hook takes a `chatRef` (reference to the chat container), a `bottomRef` (reference to the element at the bottom of the chat), `shouldLoadMore` (a boolean indicating if more messages can be loaded), `loadMore` (a function to load more messages), and `count` (the current number of messages) as props.  It attaches a scroll event listener to the chat container that triggers `loadMore` when the user scrolls to the top, conditionally.  It also includes a `useEffect` that auto-scrolls to the bottom when new messages are added, using `scrollIntoView` with a smooth behavior. The hook also ensures that the initial scroll to the bottom is performed only once upon component initialization.\n\n## **Error Handling & Side Effects**\n- **Error Handling:** The code implicitly handles potential errors by checking for the existence of `chatRef.current` and `bottomRef.current` before attempting to access their properties or methods. If either reference is null, the corresponding operations are skipped.\n- **Side Effects:**\n    - Attaches and removes a scroll event listener to the chat container element.\n    - Calls the `loadMore` function, which is expected to trigger an API call or data fetching operation to retrieve older messages and update the chat state.\n    - Uses `setTimeout` to delay the `scrollIntoView` call, allowing the DOM to update before scrolling.\n    - Updates the component's state with `setHasInitialized`.\n\n## **Dependencies & Interactions**\n- **External:**\n    - `react`: Provides the `useEffect`, `useState`, and `React.RefObject` hooks for managing component lifecycle, state, and DOM references.\n- **Internal:**\n    - The hook depends on the parent component providing the `chatRef`, `bottomRef`, `shouldLoadMore`, `loadMore`, and `count` props.  It utilizes these props to interact with the chat container and trigger the loading of more messages. The `loadMore` function is assumed to update the state of the parent component, causing the `count` prop to change and triggering the auto-scrolling effect.\n\n## **Technical Keywords**\nReact hook, scroll event, chat interface, auto-scrolling, `useEffect`, `useState`, `scrollIntoView`, DOM manipulation, message loading, conditional rendering, component lifecycle, references, `setTimeout`.\n",
        fileName: "hooks/use-chat-scroll.ts",
        similarity: 0.6575218823162748,
        sourceCode:
          'import { useEffect, useState } from "react";\n\ntype ChatScrollProps = {\n  chatRef: React.RefObject<HTMLDivElement>;\n  bottomRef: React.RefObject<HTMLDivElement>; // Reference to the bottom element in the chat container\n  shouldLoadMore: boolean; // Flag to check if more messages should be loaded\n  loadMore: () => void; // Function to load more messages\n  count: number; // The current number of messages in the chat\n};\n\nexport const useChatScroll = ({\n  chatRef,\n  bottomRef,\n  shouldLoadMore,\n  loadMore,\n  count,\n}: ChatScrollProps) => {\n  const [hasInitialized, setHasInitialized] = useState(false); // Tracks if the initial scroll has been performed\n\n  // Handle scroll events to load more messages when the user scrolls to the top\n  useEffect(() => {\n    const topDiv = chatRef?.current;\n\n    // Function to handle the scroll event\n    const handleScroll = () => {\n      const scrollTop = topDiv?.scrollTop;\n\n      // If the user scrolls to the top and more messages can be loaded, trigger loadMore\n      if (scrollTop === 0 && shouldLoadMore) {\n        loadMore();\n      }\n    };\n\n    // Add the scroll event listener to the chat container\n    topDiv?.addEventListener("scroll", handleScroll);\n\n    // Clean up by removing the scroll event listener when the component is unmounted or updated\n    return () => {\n      topDiv?.removeEventListener("scroll", handleScroll);\n    };\n  }, [shouldLoadMore, loadMore, chatRef]);\n\n  // Handle automatic scrolling when new messages are added to the chat\n  useEffect(() => {\n    const bottomDiv = bottomRef?.current;\n    const topDiv = chatRef.current;\n\n    // Function to determine if auto-scrolling should occur\n    const shouldAutoScroll = () => {\n      // If not initialized and the bottom element is present, initialize and scroll\n      if (!hasInitialized && bottomDiv) {\n        setHasInitialized(true);\n        return true;\n      }\n\n      // If the chat container is not available, do not scroll\n      if (!topDiv) {\n        return false;\n      }\n\n      // Calculate the distance from the bottom of the chat container\n      const distanceFromBottom =\n        topDiv.scrollHeight - topDiv.scrollTop - topDiv.clientHeight;\n      return distanceFromBottom <= 100;\n    };\n\n    // Perform auto-scroll if conditions are met\n    if (shouldAutoScroll()) {\n      setTimeout(() => {\n        bottomRef.current?.scrollIntoView({\n          behavior: "smooth",\n        });\n      }, 100);\n    }\n  }, [bottomRef, chatRef, count, hasInitialized]);\n};\n',
      },
      {
        summary:
          "## **Overview:** \nThe `components/media-room.tsx` file defines the `MediaRoom` component, a React functional component responsible for integrating LiveKit video conferencing into a chat application. It dynamically fetches a LiveKit token from an API endpoint based on the chat ID and user information, then renders a `LiveKitRoom` component with the token and other necessary configurations. It acts as a client-side interface for managing real-time audio and video communication within the application's chat feature.\n\n## **Core Functionality**\nThe file's primary technical purpose is to create a LiveKit video conferencing room and manage the connection, authentication, and UI display for users to participate in video calls within a specific chat context.\n\n## **Architectural Pattern**\nReact Functional Component\n\n## **Key Abstractions & Logic**\n- **`MediaRoom({ chatID, video, audio })`**: This is the main React component. It receives `chatID`, `video`, and `audio` as props determining the room ID and media settings. It uses the `useUser` hook from `@clerk/nextjs` to get user information. It fetches a LiveKit token from the `/api/livekit` endpoint using the `chatID` and user's name as query parameters. Upon receiving the token, it renders the `<LiveKitRoom>` component, passing the token, server URL, and media configurations. It handles the loading state before the token is available by displaying a loading indicator.\n- **`LiveKitRoom`**: This component, imported from `@livekit/components-react`, is the core LiveKit component that manages the connection to the LiveKit server, handles audio and video streams, and provides the basic video conferencing functionality. It's configured with the fetched token, server URL, and media preferences.\n- **`VideoConference`**: This component, imported from `@livekit/components-react`, renders the UI elements needed to manage the video conference.\n\n## **Error Handling & Side Effects**\n- **Error Handling:** The code includes a `try...catch` block when fetching the LiveKit token from the API. If an error occurs during the API call, the error is logged to the console using `console.log(e)`.\n- **Side Effects:** The component uses `useEffect` to fetch the LiveKit token whenever the user's name or `chatID` changes. This triggers an API call to `/api/livekit` to obtain the token. The state variable `token` is updated, causing the component to re-render.\n\n## **Dependencies & Interactions**\n- **External:**\n    - `react`: For creating React components and managing state.\n    - `react`, `useEffect`, `useState`:  Core React hooks for component lifecycle and state management.\n    - `@livekit/components-react`: Provides the `LiveKitRoom` and `VideoConference` components for integrating LiveKit functionality.\n    - `@livekit/components-styles`: Provides default styling for LiveKit components.\n    - `@prisma/client`: Used to denote the `Channel` type although not used in the code.\n    - `@clerk/nextjs`: Provides the `useUser` hook for accessing user information.\n    - `lucide-react`: Provides the `Loader2` component.\n- **Internal:**\n    - The component interacts with the `/api/livekit` API endpoint (assumed to be defined elsewhere) to fetch a LiveKit token.\n    - It utilizes the `useUser` hook to retrieve user details from the Clerk authentication service.\n\n## **Technical Keywords**\nReact, LiveKit, Video Conferencing, Realtime, API, useEffect, useState, Clerk, Authentication, Token, Media, Components, UI, Chat\n",
        fileName: "components/media-room.tsx",
        similarity: 0.6531631972977033,
        sourceCode:
          '"use client";\n\nimport { useEffect, useState } from "react";\nimport { LiveKitRoom, VideoConference } from "@livekit/components-react";\nimport "@livekit/components-styles";\nimport { Channel } from "@prisma/client";\nimport { useUser } from "@clerk/nextjs";\nimport { Loader2 } from "lucide-react";\n\ninterface MediaRoomsProps {\n  chatID: string;\n  video: boolean;\n  audio: boolean;\n}\n\nexport const MediaRoom = ({ chatID, video, audio }: MediaRoomsProps) => {\n  const { user } = useUser();\n  const [token, setToken] = useState("");\n\n  useEffect(() => {\n    if (!user?.firstName || !user?.lastName) return;\n\n    const name = `${user.firstName} ${user.lastName}`;\n\n    (async () => {\n      try {\n        const resp = await fetch(\n          `/api/livekit?room=${chatID}&username=${name}`\n        );\n        const data = await resp.json();\n        setToken(data.token);\n      } catch (e) {\n        console.log(e);\n      }\n    })();\n  }, [user?.firstName, user?.lastName, chatID]);\n\n  if (token == "") {\n    return (\n      <div className="flex flex-col flex-1 justify-center items-center">\n        <Loader2 className="h-7 w-7 text-zinc-500 animate-spin my-4" />\n        <p className="text-xs text-zinc-500 dark:text-zinc-400">Loading...</p>\n      </div>\n    );\n  }\n\n  return (\n    <LiveKitRoom\n      video={true}\n      audio={true}\n      token={token}\n      serverUrl={process.env.NEXT_PUBLIC_LIVEKIT_URL}\n      // Use the default LiveKit theme for nice styles.\n      data-lk-theme="default"\n      connect={true}\n    >\n      {/* Your custom component with basic video conferencing functionality. */}\n      <VideoConference />\n    </LiveKitRoom>\n  );\n};\n',
      },
      {
        summary:
          "## **Overview:** \nThis file defines the `MemberIdPage` component, a page route in a Next.js application responsible for rendering a direct conversation (direct message) between the current user and another member within a specific server. It handles authentication, data fetching, conversation creation, and conditionally renders the chat interface or a media room based on URL search parameters. The page fetches user profile and server member information, creates or retrieves a conversation between users, and displays the appropriate chat or media components.\n\n## **Core Functionality**\nThe primary function of this file is to display and manage a direct message conversation between two members within a server, including displaying chat messages, input fields, and handling video/audio calls via conditional rendering of `ChatMessages`, `ChatInput`, and `MediaRoom` components based on the `video` search parameter.\n\n## **Architectural Pattern**\nN/A\n\n## **Key Abstractions & Logic**\n- **`MemberIdPage({ params, searchParams })`**: An asynchronous React component that fetches user and server member data, retrieves or creates a direct message conversation, and renders the appropriate UI (chat or media room) based on the `video` search parameter.\n    - It first authenticates the user using `currentProfile()`. If the user is not authenticated, it redirects to the sign-in page using `auth().redirectToSignIn()`.\n    - It fetches the current member's data using `db.member.findFirst()` based on the server ID and profile ID. If the member is not found, it redirects to the home page.\n    - It retrieves or creates a conversation using `getOrCreateConversation()` between the current member and the other member specified by `params.memberId`. If no conversation is found, it redirects to the server page.\n    - It extracts `memberOne` and `memberTwo` from the conversation to determine the other member involved in the conversation.\n    - Based on the `searchParams.video` flag, it conditionally renders either the `MediaRoom` component (for video/audio calls) or the `ChatMessages` and `ChatInput` components (for text-based chat).\n\n## **Error Handling & Side Effects**\n- **Error Handling:** The code handles unauthenticated users by redirecting them to the sign-in page. It also handles cases where the current member is not found or a conversation cannot be created/retrieved, redirecting to the home or server page respectively.\n- **Side Effects:**\n    - Redirects to the sign-in page if the user is not authenticated.\n    - Redirects to the home page if the current member is not found.\n    - Redirects to the server page if a conversation cannot be created/retrieved.\n    - Makes database queries to fetch user and server member data.\n    - Makes a call to `getOrCreateConversation` which may create a new conversation in the database.\n\n## **Dependencies & Interactions**\n- **External:**\n    - `next/navigation` (redirect): Used for redirecting the user to different pages.\n    - `@clerk/nextjs/server` (auth): Used for user authentication.\n- **Internal:**\n    - `lib/conversation` (getOrCreateConversation): Used to retrieve or create a conversation between two members.\n    - `lib/current-profile` (currentProfile): Used to fetch the current user's profile.\n    - `lib/db` (db): Used as the Prisma client to interact with the database.\n    - `components/chat/chat-header` (ChatHeader): Used to display the chat header.\n    - `components/chat/chat-messages` (ChatMessages): Used to display the chat messages.\n    - `components/chat/chat-input` (ChatInput): Used to provide a chat input field.\n    - `components/media-room` (MediaRoom): Used to handle video and audio calls.\n    - The component interacts with `/api/direct-messages` and `/api/socket/direct-messages` endpoints for fetching and sending messages via REST API and WebSockets respectively.\n\n## **Technical Keywords**\nNext.js, React, Server Components, Prisma, Clerk Auth, Direct Messages, Conversations, Realtime, WebSockets, Authentication, Database, UI Components, Conditional Rendering, Media Room\n",
        fileName:
          "app/(main)/(routes)/servers/[serverId]/conversations/[memberId]/page.tsx",
        similarity: 0.6518285703868258,
        sourceCode:
          'import { redirect } from "next/navigation";\nimport { auth } from "@clerk/nextjs/server";\n\nimport { getOrCreateConversation } from "@/lib/conversation";\nimport { currentProfile } from "@/lib/current-profile";\nimport { db } from "@/lib/db";\nimport { ChatHeader } from "@/components/chat/chat-header";\nimport { ChatMessages } from "@/components/chat/chat-messages";\nimport { ChatInput } from "@/components/chat/chat-input";\nimport { MediaRoom } from "@/components/media-room";\n\ninterface MemberIdPageProps {\n  params: {\n    memberId: string;\n    serverId: string;\n  };\n  searchParams: {\n    video?: boolean;\n  };\n}\n\nconst MemberIdPage = async ({ params, searchParams }: MemberIdPageProps) => {\n  const profile = await currentProfile();\n\n  if (!profile) {\n    return auth().redirectToSignIn();\n  }\n\n  // Find the current member in the specified server using the profile ID\n  const currentMember = await db.member.findFirst({\n    where: {\n      serverId: params?.serverId,\n      profileId: profile.id,\n    },\n    include: {\n      profile: true,\n    },\n  });\n\n  if (!currentMember) {\n    return redirect("/");\n  }\n\n  // Attempt to get or create a conversation between the current member and the specified member\n  const conversation = await getOrCreateConversation(\n    currentMember.id,\n    params.memberId\n  );\n\n  if (!conversation) {\n    return redirect(`/servers/${params.serverId}`);\n  }\n\n  // Extract memberOne and memberTwo from the conversation\n  const { memberOne, memberTwo } = conversation;\n\n  // Determine the other member in the conversation\n  const otherMember =\n    memberOne.profileId === profile.id ? memberTwo : memberOne;\n\n  return (\n    <div className="bg-white dark:bg-[#313338] flex flex-col h-full">\n      <ChatHeader\n        serverId={params.serverId}\n        name={otherMember.profile.name}\n        type="coversation"\n        imageUrl={otherMember.profile.imageUrl}\n      />\n\n      {searchParams.video && (\n        <MediaRoom chatID={conversation.id} video={true} audio={true} />\n      )}\n\n      {!searchParams.video && (\n        <>\n          <ChatMessages\n            member={currentMember}\n            name={otherMember.profile.name}\n            chatId={conversation.id}\n            type="conversation"\n            apiUrl="/api/direct-messages" // API endpoint for fetching messages\n            paramKey="conversationId"\n            paramValue={conversation.id}\n            socketUrl="/api/socket/direct-messages" // API endpoint for sending messages\n            socketQuery={{\n              conversationId: conversation.id,\n            }}\n          />\n          <ChatInput\n            name={otherMember.profile.name}\n            type="conversation"\n            apiUrl="/api/socket/direct-messages" // API endpoint for sending messages\n            query={{\n              conversationId: conversation.id,\n            }}\n          />\n        </>\n      )}\n    </div>\n  );\n};\n\nexport default MemberIdPage;\n',
      },
      {
        summary:
          '## **Overview:** \nThe `chat-header.tsx` file defines the `ChatHeader` React component, which is responsible for rendering the header section of a chat interface, displaying channel or conversation-specific information. It dynamically renders content based on the `type` prop ("channel" or "conversation"), showing either a hash icon for channels or a user avatar for conversations. It also includes a mobile toggle for navigation on smaller screens, the name of the channel/conversation, a video call button for conversations, and a socket indicator.\n\n## **Core Functionality**\nThe `ChatHeader` component renders a visually informative header for a chat interface, adapting its content based on whether it\'s displaying a channel or a direct conversation.\n\n## **Architectural Pattern**\nN/A\n\n## **Key Abstractions & Logic**\n- **`ChatHeader({ serverId, name, type, imageUrl })`**: This React functional component renders the chat header.\n    - **Logic:** It conditionally renders a hash icon for channels, a user avatar for conversations, the chat name, a mobile toggle button, a video call button (for conversations), and a socket connection indicator. The `type` prop determines which elements are displayed. It uses CSS classes for styling.\n    - **Parameters:**\n        - `serverId`: string representing the server ID. Used by the `MobileToggle` component.\n        - `name`: string representing the name of the channel or conversation.\n        - `type`: string, either "channel" or "coversation", determining the header\'s content.\n        - `imageUrl`: optional string, URL of the user\'s avatar (only used for conversations).\n    - **Returns:** A JSX element representing the chat header.\n\n## **Error Handling & Side Effects**\n- **Error Handling:** The component itself doesn\'t directly handle errors. Any errors arising from rendering child components (e.g., `UserAvatar`, `SocketIndicator`) would need to be handled within those respective components.\n- **Side Effects:** The component itself has no direct side effects. However, `MobileToggle`, `UserAvatar`, `SocketIndicator`, and `ChatVideoButton` might have their own side effects (e.g. connecting to a socket or rendering data.)\n\n## **Dependencies & Interactions**\n- **External:**\n    - `lucide-react`: Used for the `Hash` icon.\n- **Internal:**\n    - `MobileToggle`: Component for toggling the mobile navigation menu. Receives `serverId` as prop.\n    - `UserAvatar`: Component for displaying user avatars. Receives `imageUrl` and styling props.\n    - `SocketIndicator`: Component that indicates the status of the socket connection.\n    - `ChatVideoButton`: Button component to initiate a video call (only rendered for conversations).\n\n## **Technical Keywords**\nReact, component, chat header, UI, conditional rendering, lucide-react, props, JSX, serverId, channel, conversation\n',
        fileName: "components/chat/chat-header.tsx",
        similarity: 0.6459897415313053,
        sourceCode:
          'import { Hash } from "lucide-react";\n\nimport { MobileToggle } from "@/components/mobile-toggle";\nimport { UserAvatar } from "../user-avatar";\nimport { SocketIndicator } from "@/components/socket-indicator";\nimport { ChatVideoButton } from "@/components/chat/chat-video-button";\n\ninterface ChatHeaderProps {\n  serverId: string;\n  name: string;\n  type: "channel" | "coversation";\n  imageUrl?: string;\n}\n\nexport const ChatHeader = ({\n  serverId,\n  name,\n  type,\n  imageUrl,\n}: ChatHeaderProps) => {\n  return (\n    <div className="text-md font-semibold px-3 flex items-center h-12 border-neutral-200 dark:border-neutral-800 border-b-2">\n      {/* Toggle Component for mobile view */}\n      <MobileToggle serverId={serverId} />\n\n      {/* Display a hash icon if the type is "channel" */}\n      {type === "channel" && (\n        <Hash className="w-5 h-5 text-zinc-500 dark:text-zinc-400 mr-2" />\n      )}\n\n      {type === "coversation" && (\n        <UserAvatar src={imageUrl} className="h-8 w-8 md:h-8 md:w-8 mr-2" />\n      )}\n\n      {/* Display the name of the channel or conversation */}\n      <p className="font-semibold text-md text-black dark:text-white">{name}</p>\n\n      <div className="ml-auto flex items-center">\n        {type === "coversation" && <ChatVideoButton />}\n        <SocketIndicator />\n      </div>\n    </div>\n  );\n};\n',
      },
      {
        summary:
          "## **Overview:** \nThis file defines the `ChannelIdPage` component, a server-side rendered page in a Next.js application responsible for displaying the chat interface for a specific channel within a server. It handles authentication, data fetching for the channel and member, and renders the appropriate chat components based on the channel type (text, audio, or video). It also ensures that only members of the server can access the channel page.\n\n## **Core Functionality** The file fetches channel and member data based on route parameters and renders the appropriate chat interface (text, audio, or video) based on the channel type, ensuring only authorized members can access the channel.\n\n## **Architectural Pattern** N/A\n\n## **Key Abstractions & Logic**\n- **`ChannelIdPage({ params }: ChannelIdPage)`**: This is an asynchronous React component that receives `serverId` and `channelId` from the route parameters. It first checks if the user is authenticated and redirects to the sign-in page if not. Then, it fetches the channel data from the database using `db.channel.findUnique` and checks if the user is a member of the server using `db.member.findFirst`. If the channel or member is not found, it redirects to the homepage. Finally, it renders the `ChatHeader`, and based on the `channel.type`, it conditionally renders the `ChatMessages` and `ChatInput` components for text channels or the `MediaRoom` component for audio/video channels.\n- **`ChatHeader`**: A component responsible for displaying the channel name and server details. It receives `name`, `serverId`, and `type` as props.\n- **`ChatMessages`**: A component that displays the chat messages for a text channel. It receives props such as `name`, `member`, `chatId`, `type`, `apiUrl`, `socketUrl`, `socketQuery`, `paramKey`, and `paramValue`.\n- **`ChatInput`**: A component that provides the input field for sending messages in a text channel. It receives props such as `name`, `type`, `apiUrl`, and `query`.\n- **`MediaRoom`**: A component that provides the audio/video chat interface. It receives props such as `chatID`, `audio`, and `video`.\n\n## **Error Handling & Side Effects**\n- **Error Handling:** The code handles potential errors by checking if the user is authenticated and if the channel and member exist. If any of these checks fail, the user is redirected to the sign-in page or the homepage.\n- **Side Effects:** The component fetches data from the database using `db.channel.findUnique` and `db.member.findFirst`. It also redirects the user to different pages based on certain conditions using `redirect` and `auth().redirectToSignIn()`.\n\n## **Dependencies & Interactions**\n- **External:**\n  - `next/navigation`: Used for redirecting the user to different pages.\n  - `@clerk/nextjs/server`: Used for authentication and redirection to the sign-in page.\n  - `@prisma/client`: Used for interacting with the database.\n  - `@/lib/current-profile`: Used to fetch the current user's profile.\n- **Internal:**\n  - `ChatHeader`: Renders the channel header.\n  - `ChatMessages`: Renders the chat messages for text channels.\n  - `ChatInput`: Renders the input field for sending messages in text channels.\n  - `MediaRoom`: Renders the audio/video chat interface.\n  - `db`: Prisma client instance for database interactions.\n\n## **Technical Keywords**\nNext.js, server-side rendering, React component, authentication, Prisma, database query, channel, member, chat interface, real-time messaging, media room, route parameters.\n",
        fileName:
          "app/(main)/(routes)/servers/[serverId]/channels/[channelId]/page.tsx",
        similarity: 0.6415728945158723,
        sourceCode:
          'import { currentProfile } from "@/lib/current-profile";\nimport { auth } from "@clerk/nextjs/server";\n\nimport { db } from "@/lib/db";\nimport { redirect } from "next/navigation";\nimport { ChatHeader } from "@/components/chat/chat-header";\nimport { ChatInput } from "@/components/chat/chat-input";\nimport { ChatMessages } from "@/components/chat/chat-messages";\nimport { ChannelType } from "@prisma/client";\nimport { MediaRoom } from "@/components/media-room";\n\ninterface ChannelIdPage {\n  params: {\n    serverId: string;\n    channelId: string;\n  };\n}\n\nconst ChannelIdPage = async ({ params }: ChannelIdPage) => {\n  const profile = await currentProfile();\n\n  if (!profile) {\n    return auth().redirectToSignIn();\n  }\n\n  // Query the database to fetch the channel by its ID\n  const channel = await db.channel.findUnique({\n    where: {\n      id: params?.channelId,\n    },\n  });\n\n  // Query the database to check if the user is a member of the server\n  const member = await db.member.findFirst({\n    where: {\n      serverId: params?.serverId,\n      profileId: profile.id,\n    },\n  });\n\n  // If the channel does not exist or the user is not a member, redirect to the homepage\n  if (!channel || !member) {\n    redirect("/");\n  }\n  return (\n    <div className="bg-white dark:bg-[#313338] flex flex-col h-full">\n      <ChatHeader\n        name={channel.name}\n        serverId={channel.serverId}\n        type="channel"\n      />\n\n      {channel.type === ChannelType.TEXT && (\n        <>\n          <ChatMessages\n            name={channel.name}\n            member={member}\n            chatId={channel.id}\n            type="channel"\n            apiUrl="/api/messages" // API endpoint to fetch messages\n            socketUrl="/api/socket/messages" // WebSocket URL for real-time messaging\n            socketQuery={{\n              channelId: channel.id,\n              serverId: channel.serverId,\n            }}\n            paramKey="channelId"\n            paramValue={channel.id}\n          />\n          <ChatInput\n            name={channel.name}\n            type="channel"\n            apiUrl="/api/socket/messages" // API endpoint for sending messages\n            query={{\n              channelId: channel.id,\n              serverId: channel.serverId,\n            }}\n          />\n        </>\n      )}\n      {channel.type === ChannelType.AUDIO && (\n        <MediaRoom chatID={channel.id} audio={true} video={false} />\n      )}\n\n      {channel.type === ChannelType.VIDEO && (\n        <MediaRoom chatID={channel.id} audio={false} video={true} />\n      )}\n    </div>\n  );\n};\n\nexport default ChannelIdPage;\n',
      },
      {
        summary:
          '## **Overview:** \nThis file defines the `ChatInput` component, a React component responsible for providing a user interface for composing and sending chat messages. It handles form management, validation, and submission of chat messages to a specified API endpoint. The component utilizes `react-hook-form` and `zod` for form management and schema validation, respectively. It supports sending messages to either conversations or channels, adapting the input placeholder accordingly.\n\n## **Core Functionality**\nThe primary function of this file is to render a form that allows users to input and submit chat messages to a specified API endpoint, handling form state, validation, and submission logic.\n\n## **Architectural Pattern**\nReact Component with Hook Usage\n\n## **Key Abstractions & Logic**\n- **`ChatInput({ apiUrl, query, name, type })`**: This React functional component renders a chat input form. It accepts `apiUrl` (the API endpoint for sending messages), `query` (query parameters to include in the API request, like channel or conversation ID), `name` (the name of the channel or conversation), and `type` ("conversation" or "channel"). It initializes a form using `react-hook-form` and `zod` for validation based on the `formSchema`. On submission, it sends a POST request to the `apiUrl` with the form values, resets the form, and refreshes the router. It also includes buttons for attaching files and adding emojis.\n- **`formSchema`**: A Zod schema defining the shape and validation rules for the chat input form. It expects a `content` field, which must be a string with a minimum length of 1 character.\n- **`onSubmit(values)`**: An asynchronous function that handles form submission. It constructs the API URL using `qs.stringifyUrl`, including the `apiUrl` and `query` parameters. It then sends a POST request to this URL with the form values. Upon successful submission, it resets the form and triggers a router refresh.\n\n## **Error Handling & Side Effects**\n- **Error Handling:** The `onSubmit` function includes a try-catch block to handle potential errors during the API request. If an error occurs, it logs the error to the console.\n- **Side Effects:**\n  - Submitting the form triggers an API call to the specified `apiUrl`.\n  - Successful form submission resets the form state, clearing the input field.\n  - Submitting the form triggers a router refresh, likely to update the displayed chat messages.\n  - Clicking the plus icon opens a modal via `useModal`.\n\n## **Dependencies & Interactions**\n- **External:**\n  - `react`: Core React library for building UI components.\n  - `react-hook-form`: A library for simplifying form management in React.\n  - `zod`: A TypeScript-first schema declaration and validation library used to define the form schema.\n  - `@hookform/resolvers/zod`: Integrates Zod with React Hook Form for schema validation.\n  - `query-string`: A library for parsing and stringifying URL query strings.\n  - `axios`: A promise-based HTTP client for making API requests.\n  - `lucide-react`: A library of icons.\n  - `next/navigation`: Provides routing functionality for Next.js applications.\n- **Internal:**\n  - `components/ui/form`: Provides UI components for creating forms.\n  - `components/ui/input`: Provides a styled input component.\n  - `hooks/use-modal-store`: A custom hook for managing the state of a modal.\n  - `components/emoji-picker`: Provides a UI component for selecting emojis.\n\n## **Technical Keywords**\nReact component, chat input, form management, Zod validation, react-hook-form, API request, message submission, query parameters, asynchronous, Next.js, router refresh\n',
        fileName: "components/chat/chat-input.tsx",
        similarity: 0.6387543675429158,
        sourceCode:
          '"use client";\n\nimport * as z from "zod";\nimport { useForm } from "react-hook-form";\nimport { zodResolver } from "@hookform/resolvers/zod";\nimport qs from "query-string";\nimport axios from "axios";\n\nimport { Form, FormControl, FormField, FormItem } from "@/components/ui/form";\nimport { Input } from "@/components/ui/input";\nimport { Plus, Smile } from "lucide-react";\nimport { useModal } from "@/hooks/use-modal-store";\nimport { EmojiPicker } from "@/components/emoji-picker";\nimport { useRouter } from "next/navigation";\n\ninterface ChatInputProps {\n  apiUrl: string; // The API endpoint for sending chat messages\n  query: Record<string, any>; // Additional query parameters for the API\n  name: string;\n  type: "conversation" | "channel";\n}\n\n// Define a schema using zod to validate form input\nconst formSchema = z.object({\n  content: z.string().min(1),\n});\n\nexport const ChatInput = ({ apiUrl, query, name, type }: ChatInputProps) => {\n  const { onOpen } = useModal();\n  const router = useRouter();\n\n  // Initialize form using react-hook-form and zod for schema validation\n  const form = useForm<z.infer<typeof formSchema>>({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      content: "",\n    },\n  });\n\n  const isLoading = form.formState.isSubmitting;\n\n  // Define the form submission handler\n  const onSubmit = async (values: z.infer<typeof formSchema>) => {\n    try {\n      const url = qs.stringifyUrl({\n        url: apiUrl, // apiUrl="/api/socket/messages" or "api/socket/direct-messages"\n        query: query, // The query parameters (e.g., channelId, serverId) or (conversatioId)\n      });\n      await axios.post(url, values);\n\n      form.reset();\n      router.refresh();\n    } catch (error) {\n      console.log(error);\n    }\n  };\n  return (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)}>\n        <FormField\n          control={form.control}\n          name="content"\n          render={({ field }) => (\n            <FormItem>\n              <FormControl>\n                <div className="relative p-4 pb-6">\n                  <button\n                    type="button"\n                    onClick={() => onOpen("messageFile", { apiUrl, query })}\n                    className="absolute top-7 left-8 h-[24px] w-[24px]\n                     bg-zinc-500 dark:bg-zinc-400 hover:bg-zinc-600\n                      dark:hover:bg-zinc-300 transition rounded-full p-1 \n                      flex items-center justify-center "\n                  >\n                    <Plus className="text-white dark:text-[#313338]" />\n                  </button>\n                  <Input\n                    disabled={isLoading}\n                    className="px-14 py-6 bg-zinc-200/90 dark:bg-zinc-700/75 \n                    border-none border-0 focus-visible:ring-0 focus-visible:ring-offset-0\n                     text-zinc-600 dark:text-zinc-200"\n                    placeholder={`Message ${\n                      type === "conversation" ? name : "#" + name\n                    }`}\n                    {...field}\n                  />\n                  <div className="absolute top-7 right-8">\n                    <EmojiPicker\n                      onChange={\n                        (emoji: string) =>\n                          field.onChange(`${field.value} ${emoji}`) // Adds selected emoji to the current input value\n                      }\n                    />\n                  </div>\n                </div>\n              </FormControl>\n            </FormItem>\n          )}\n        />\n      </form>\n    </Form>\n  );\n};\n',
      },
      {
        summary:
          '## **Overview:** \nThe `SocketIndicator.tsx` file is a React client component that provides a visual indication of the WebSocket connection status. It leverages the `useSocket` hook to determine if the application is connected to the WebSocket server. Based on the connection status, it renders a badge with different text and styling to inform the user about whether they are receiving real-time updates or using a fallback polling mechanism. This component contributes to the user experience by providing immediate feedback on the application\'s connectivity.\n\n## **Core Functionality**\nThe primary technical purpose of this file is to render a status badge indicating the real-time WebSocket connection status, switching between a "Live" indicator when connected and a "Fallback: Polling every 1s" indicator when disconnected.\n\n## **Architectural Pattern**\nReact Component\n\n## **Key Abstractions & Logic**\n- **`SocketIndicator()`**: This React functional component renders a `Badge` component from the `ui` library. It uses the `useSocket` hook to determine the WebSocket connection status (`isConnected`). If `isConnected` is false, it renders a badge indicating the fallback polling mechanism. If `isConnected` is true, it renders a badge indicating live, real-time updates. It returns a JSX element representing the appropriate status badge.\n\n## **Error Handling & Side Effects**\n- **Error Handling:** This component does not directly handle errors. The error handling related to the socket connection is presumably managed within the `useSocket` hook or the underlying socket provider.\n- **Side Effects:** This component doesn\'t have any explicit side effects. The `useSocket` hook, which it depends on, likely manages the side effects related to establishing and maintaining the WebSocket connection.\n\n## **Dependencies & Interactions**\n- **External:**\n  - `react`: Provides the foundation for building the React component.\n  - `@/components/providers/socket-provider`: This imports the `useSocket` hook, which is the primary means of interacting with the WebSocket connection status.\n  - `@/components/ui/badge`: Imports the `Badge` component from the application\'s UI library for displaying the status indicator.\n- **Internal:**\n  - This component relies on the `useSocket` hook provided by the `socket-provider` to access the connection status. It then renders a visual indicator using the `Badge` component.\n\n## **Technical Keywords**\nReact, component, WebSocket, socket.io, real-time, status indicator, `useSocket`, hook, badge, UI, client-side, connection status, polling, fallback\n',
        fileName: "components/socket-indicator.tsx",
        similarity: 0.6369961664302091,
        sourceCode:
          '"use client";\n\nimport { useSocket } from "@/components/providers/socket-provider";\nimport { Badge } from "@/components/ui/badge";\n\nexport const SocketIndicator = () => {\n  const { isConnected } = useSocket();\n\n  if (!isConnected) {\n    return (\n      <Badge\n        variant={"outline"}\n        className="bg-yellow-600 text-white border-none"\n      >\n        Fallback: Polling every 1s\n      </Badge>\n    );\n  }\n\n  return (\n    <Badge\n      variant={"outline"}\n      className="bg-emerald-600 text-white border-none"\n    >\n      Live: Real-time updates\n    </Badge>\n  );\n};\n',
      },
    ],
  },
];
